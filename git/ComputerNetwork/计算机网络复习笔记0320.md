1. 为什么需要“三次握手”
client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但server收到此失效的连接请求报文段后，就误以为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用"三次握手"，那么只要server发出确认，新的连接就建立了由于现在client并没有建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来护具。这样，server的很多资源就白白浪费掉了。

2. 为什么需要“四次挥手”
因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。


# 外部排序
多路归并排序
根据内存的大小，将有n个记录的磁盘文件分批读入内存，采用有效的内存排序方法进行排序，将其预处理为若干个有序的子文件，这些有序子文件就是初始顺串，然后采用合并的方法将这些初始顺串逐趟合并成一个有序文件

多路归并排序算法的过程大致为：

1）：首先将k个归并段中的首元素关键字依次存入b[0]--b[k-1]的叶子结点空间里，然后调用CreateLoserTree创建败者树，创建完毕之后最小的关键字下标（即所在归并段的序号）便被存入ls[0]中。然后不断循环：

2）把ls[0]所存最小关键字来自于哪个归并段的序号得到为q，将该归并段的首元素输出到有序归并段里，然后把下一个元素关键字放入上一个元素本来所 在的叶子结点b[q]中，调用Adjust顺着b[q]这个叶子结点往上调整败者树直到新的最小的关键字被选出来，其下标同样存在ls[0]中。循环这个 操作过程直至所有元素被写到有序归并段里。

# c++字节补齐问题，使用#pragma pack(1)来限定字节对齐方式等各种条件
指针的理解不深导致一些野指针，内存泄露等问题，所以就不赘述。智能指针正好能够弥补这些问题，因为它本质是存放在栈的模板对象，只是在栈内部包了一层指针。而栈在其生命周期结束时，其中的指针指向的堆内存也自然被释放了。因而实现了智能管理的效果，不需要考虑内存问题了，其实有点类似某种单例写法，程序运行结束，也不用考虑单例对象内存问题。
* unique_ptr中的拷贝构造和赋值操作符delete了，所以也就意味着，他和auto_ptr有区别，控制权唯一，不能随意转换
* shared_ptr可以直接赋值和调用拷贝构造函数，且不会清空原本的智能指针
4.weak_ptrred_ptr

weak_ptr更像是shared_ptr的助手：

1、他不像其余三种，可以通过构造函数直接分配对象内存；他必须通过shared_ptr来共享内存。

2、没有重载opreator*和->操作符，也就意味着即使分配到对象，他也没法使用该对象

3、不主动参与引用计数，即，share_ptr释放了，那么weak_ptr所存的对象也释放了。

4、使用成员函数use_count()可以查看当前引用计数，expired()判断引用计数是否为空。

## 为什么要四次挥手
因为FIN释放连接报文和ACK确认接收报文是分别再两次握手中传输的
当主动方再数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回ACK确认收到报文，当被东方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。

## CLOSE-WAIT和TIME-WAIT的状态和意义
在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到该请求之后，**服务器**进入了**CLOSE-WAIT**状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。

> 当出现很多CLOSE-WAIT时，首先检查是不是代码问题（看是否服务端程序忘记关闭连接）；调整系统参数，包括句柄相关参数和TCP/IP的参数来缩短这个时间。

TIME-WAIT发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入该状态，若取消该状态，即客户端在收到服务端的FIN报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的来凝接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。初次之外，假设客户端最后依次发送的ACK包在传输的时候丢失了，由于TCP协议的超时重传机制，服务端将重发FIN报文，若客户端并没有维持TIME-WAIT状态而直接关闭的话，当收到服务端重新发来的FIN包时，客户端就会用RST包来相应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。

## TIME_WAIT状态会导致什么问题，怎么解决？
在高并发短连接的TCP服务器上，当服务器处理完请求后**主动请求关闭连接**，这样服务器上会有大量的连接处于TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的连接失败。解决方案：修改配置或设置SO_REUSEADDR套接字，使得服务器处于TIME-WAIT状态下的端口能够快速回收和重用。

## TIME-WAIT为什么是2MSL
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指一段TCP报文在传输过程中的最大声明周期。若服务器在1MSL内没有收到客户端发出的ACK确认报文，再次向客户端发出FIN报文。如果客户端在2MSL内收到了服务器再次发来的FIN报文，说明服务器由于一些原因并没有收到客户端发出的ACK确认报文，客户端将再次向服务器发出ACK确认报文，并重新开始2MSL的计时。

## TCP是如何保证可靠性的
* 数据分块
* 序列号和确认应答
* 校验和
* 流量控制
* 拥塞控制
* ARQ协议
* 超时重传

## TCP的停止等待协议
发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。

## TCP流量控制与拥塞控制
滑动窗口：接收方返回的ACK中会包含自己的接收窗口大小。如果接收窗口已满，需要坚持计时器来辅助发送方周期地向接收方查询，以便发现窗口是否变大，如果变为非零边继续发送数据。
慢开始和拥塞避免、快重传和快恢复
> 快重传：接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才稍低进行确认。
> 快恢复：当发送方连续收到三个重复确认，执行乘法减小，慢开始门限ssthresh值减半。

## TCP粘包和拆包
发送方写入的数据大于套接字缓冲区的大小，此时件会发生拆包。
发送方写入的数据小于套接字缓冲区的大小，由于TCP默认使用Nagle算法，只有当收到一个确认后，才将分组发送到对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。

## ICMP协议：因特网控制报文协议
主要时传输控制信息来辅助网络层通信
* Ping(Packet Internet Groper) 
因特网包探测器，用于测试网络连接量。本地主机通过向目的主机发送ICMP Echo请求报文，目的主机收到之后会发送Echo相应报文，Ping会根据时间和成功响应的次数估算出数据包往返时间(TTL)以及丢包率从而推断网络是否畅通。
* TraceRoute
主要用来跟踪一个分组从源点耗费最少TTL到达目的地的路径。
首先，TraceRoute会发送一个TTL为1的IP数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将TTL的值减1，此时TTL=0,所以路由器会将这个数据报丢掉，并返回一个差错报告报文。随后源主机逐渐增大TTL值直到数据报能够刚好到达目的主机，此时目的主机要向源主机发送ICMP终点不可达差错报告报文，这样源主机便知道了到达目的主机所经过的路由器IP地址以及到达每个路由器的往返时间。

## GET POST PUT DELETE
1.根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

* 注意：这里安全的含义仅仅是指是非修改信息。

(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。