# Apache与Tomcat,Nginx
## Apache
支持模块多，性能稳定，Apache本身是静态解析，适合静态HTML、图片登，但可以通过扩展脚本、模块等支持动态页面等。
* 缺点：配置相对复杂， 自身不支持动态页面
* 优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。
## Tomcat
* 缺点：只能做java服务器
* 优点：动态解析容器，处理动态请求，是编译JSP/Servlet的容器
## Nginx
是一个高性能的HTTP和方向代理服务器，同时也是一个IMAP/POP3/SMTP代理服务器，其特点是占有内存少，并发能力强，易于开发，部署方便。Nginx支持多语言通用服务器。
缺点：Nginx只适合静态和反向代理。
优点：负载均衡、反向代理、处理静态文件优势，Nginx处理静态请求的速度高于Apache。Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理。

## nginx和Apache的区别
Apache是同步多进程模型，一个连接对应一个进程，而nginx是异步的，多个连接（万级别）可以对应一个进程。
nginx轻量级，抗并发，处理静态文件好
Apache超稳定，对PHP支持比较简单，nginx需要配合其他后端用，处理动态请求有优势，建议使用前端nginx抗并发，后端apache集群，配合起来会更好
nignx的正向代理和反向代理

2) apache 相对于nginx 的优点
apache的 rewrite（重写） 比nginx 的强大 ;
支持动态页面;
支持的模块多，基本涵盖所有应用;
性能稳定，而nginx相对bug较多。

3) 两者优缺点比较
Nginx 配置简洁, Apache 复杂 ;
Nginx 静态处理性能比 Apache 高 3倍以上 ;
Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端用;Apache 的组件比 Nginx 多 ;
apache是同步多进程模型，一个连接对应一个进程;nginx是异步的，多个连接(万级别)可以对应一个进程;
nginx处理静态文件好,耗费内存少;
动态请求由apache去做，nginx只适合静态和反向;
Nginx适合做前端服务器，负载性能很好;
Nginx本身就是一个反向代理服务器 ，且支持负载均衡

## 正向代理
隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求
> 例如：用浏览器访问http://www.google.com时，被block，可以通过在国外搭建一台代理服务器，让代理帮忙去请求，代理把请求结果返回给我

## 反向代理
隐藏了真实的服务端，当我们请求www.baidu.com的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台并不知道。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。

# 对称加密与非对称加密
## 对称加密
你用这种算法A加上这个密钥S加密出来的数据，可以被我使用同样的算法A（逆着跑一遍）加密钥S解密出来，反之同理。这种加密方式被叫做对称的。

## HTTPS
非对称加密RSA的安全性依赖了很大的整数。所以当n很大时，e和d也可能会很大。假如服务器要传输给我们的是一整张网页。使用非对称加密的方法加密时，这个包含数百k的数据被转换成一个巨大的整数，再对它做e次方的操作，这将是非常耗时的（或者把数据拆成很多小整数，但要做e次方操作都是很耗时的）。

所以HTTPS选择了握手时交换密钥的方案（非对称加密与对称加密混合）
总的来说，握手过程中，服务器会发出一张证书（带着公钥）
，客户端用公钥加密了一段较短的数据S，并返回给服务器，服务器用私钥解开，拿到S。此时，握手步骤完成。S成为了一个被安全传输到对方手中的对称加密密钥。此后，此后，服务器与客户端只需要用S作为密钥进行依次对称的加密就好。

## 证书体系与中间人劫持
一个HTTPS网站响应给我们的并不是一个公钥，而是证书。证书上包含了公钥，还包含了域名、签发机构、有效期、签名等等。

因为这套证书体系已经根植于每一个操作系统里了。每一个操作系统里，都内置了数十张根证书，每个根证书都对应一个非常权威的证书签发机构。这些根证书上记录了各个机构的公钥。

当网站找证书机构购买了一份合法的证书时，网站申请的证书上的公钥、域名、有效期等信息会被计算一次hash，然后证书机构用它的私钥给这个hash加密一次。这个加密结果就是证书的签名。

当网站的合法HTTPS证书到达你的电脑上，这个证书上带有签发机构的信息（具体来说应该是一条证书链），你的浏览器会用这个签发机构对应的操作系统内置根证书上的公钥，去解开网站HTTPS证书的签名（还记得吗，由于运算结果有周期性，所以用私钥加密的信息可以用公钥解开）。发现签名解开的hash与证书信息内容的hash一致，就可以证明证书是合法的了。

通常来说，证书签发机构的审核非常严格，如果无法证明www.zhihu.com这个域名属于他，签发机构是不会给他签发一个知乎域名的证书的。而如果中间人用了其他域名的证书，浏览器会发现你请求的域名和返回的证书不一致。**HTTPS的安全性仍然保证在『证书签发机构一定都是很有良心的』这种脆弱的基础上**。

# 状态码
## 1开头的状态码
100 Continue 继续。客户端应继续其请求
101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。
## 2开头的状态码
200 OK 请求成功。一般用于GET与POST请求
201 Created 已创建。成功请求并创建了新的资源
202 Accepted 已接受。已经接受请求，但未处理完成
## 3开头的状态码
300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端(例如：浏览器)选择
301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替
302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI
304 Not Modified 未修改。304Not Modified未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
305 Use Proxy 使用代理。所请求的资源必须通过代理访问
## 4开头的状态码
400 Bad Request 客户端请求的语法错误，服务器无法理解。
401 Unauthorized 请求用户的身份验证
403 Forbidden 服务器理解客户端的请求，但是拒绝执行次请求
404 Not Found 服务器无法根据客户端的请求找到资源。
## 5开头的状态码
500 Internal Server Error服务器内部错误，无法完成请求
501 Not Implemented 服务器不支持请求的功能，无法完成请求
502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求
503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

## GET和POST
GET:请求指定的页面信息，并返回具体内容，通常只用于读取数据。
HEAD: 类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。
POST:向指定资源提交数据进行处理请求。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的更改。
PUT: 替换指定的资源，没有的话就新增。
DELETE:请求服务器删除URL标识的资源数据
CONNECT:将服务器作为代理，让服务器代替用户进行访问。
OPTIONS:向服务器发送该方法，会返回对指定资源所支持的HTTP请求方法。
TRACE:回显服务器收到的请求数据，即服务器返回自己收到的数据，主要用于测试和诊断。
PATCH:是对PUT方法的补充，用来对已知资源进行局部更新。

### GET和POST的区别
1. get提交的数据会放在URL之后，并且请求参数会被完整的保留在浏览器的记录里，由于参数直接暴露在URL中，可能会存在安全问题，因此往往用于获取资源信息。而post参数放在请求主体中，并且参数不会被保留。主要用于修改服务器上的资源。
2. get请求只支持URL编码，post请求支持多种编码格式。
> 四种常见的POST提交数据方式：apllication/x-www-form-urlencoded(即url编码，用Ajax提交数据时的方式), multipart/form-data（使用表单上传数据）, application/json（用来告诉服务端消息主体是序列化后的JSON字符串）, text/xml
3. get支持ASCII字符格式的参数，而post方法没有限制。
4. get提交的数据大小有限制（由浏览器限制），而后者没有收到浏览器限制。
5. get方式需要使用Request.QueryString来取得变量的值，而post方式通过Request.Form来获取。
6. get方法产生一个TCP数据包，post方法产生两个。

## HTTPS的建立过程
1. 客户端发起一个HTTPS请求，并连接到服务器的443端口，发送的信息主要包括自身所支持的算法列表和密钥长度等；(Client Hello)
2. 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其他密钥组件一同发送给客户端。（Server Hello）
3. 服务端向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。（Acknowledge验证），（客户端接收到数字证书后会进行使用CA机构的公钥进行签名验证）
4. 最后服务端发送一个完成报文通知客户端SSL的第一阶段已经协商完成。（Server done）
5. SSL第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，成为pre_master_secre(预祝密钥)，并给该报文是经过证书中的公钥加密过的。
6. 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre加密的。
7. 客户端向服务端发送一个finish报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。
8. 服务端同样发送与第6步中相同作用的报文，以让客户端进行确认，最后发送finish报文告诉客户端自己能够正确解密报文。
9. 但服务端和客户端的finish报文交换完成之后，SSL连接就算建立完成了，采用对称加密的方式进行明文传输。

## HTTP/1.1 和HTTP/1.0的区别
1. 缓存处理
2. 节约带宽
3. 错误通知的管理（新增24个错误状态响应码）
4. Host请求头
5. 长连接

## HTTP/1.X和HTTP/2.0的区别
1. 采用二进制传送，流具有流ID标识和优先级
2. HTTP/2.0支持多路复用
3. HTTP/2.0头部压缩
4. HTTP/2.0支持服务器推送