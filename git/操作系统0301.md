# fork
fork系统调用会创建一个与调用进程相同的副本，父进程和子进程拥有相同的内存映像、同样的环境字符串和同样的打开文件。通常，紫禁城接着执行execve或一个类似的系统调用，以修改其内存映像并运行一个新的程序。

# 多线程例子
万维网服务器。Web服务器可以把获得大量访问的页面集合保存在内存中，避免到磁盘去调入这些页面，从而改善性能。这样的一种页面积核称为高速缓存(cache)。
1. 一个称为分派程序(dispatcher)的线程从网络中读入工作请求。在检查请求之后,分派线程挑选一个空转的（即被阻塞的）工作线程(worker thread),提交该请求，唤醒睡眠的工作线程，将它从阻塞状态转为就绪状态。
2. 在工作线程被唤醒后，它见擦汗有关的请求是否在Web页面高速缓存之中，如果没有，该线程开始一个从磁盘调入页面的read操作，并且阻塞直到该磁盘操作完成。

# 进程间通信（Inter Process Communication, IPC）
## 信号量
使用信号量的生产者-消费者问题
```c++
# define N 100   /*缓冲区中的槽数目*/
typedef int semaphore;   /*信号量*/
semaphore mutex = 1;  /*控制对临界区的访问*/
semaphore empty = N;  /*计数缓冲区的空槽数目*/
semaphore full = 0;  /*计数缓冲区的满槽数目*/

void producer(void)
{
    int item;

    while(TRUE)
    {
        item = produce_item();  /*产生放在缓冲区中的一些数据*/
        down(&empty);  /*将空槽数目减1*/
        down(&mutex);  /*进入临界区*/
        insert_item(item);  /*将性数据项放到缓冲区中*/
        up(&mutex);  /*离开临界区*/
        up(&full);  /*将满槽的数目加1*/
    }

    void consumer(void)
    {
        int item;

        while(TRUE)
        {
            down(&full);   /*将满槽数目减1*/
            down(&mutex);  /*进入临界区*/
            item = remove_item();  /*从缓冲区中取出数据项*/
            up(&mutex);  /*离开临界区*/
            up(&empty);  /*将空槽数目加1*/
            consume_item(item);  /*处理数据项*/
        }
    }
}
```
## 管道
管道分为有名管道和无名管道
无名管道是一种半双工的通信方式,数据只能单向流动,而且只能在具有亲缘关系的进程间使用.进程的亲缘关系一般指的是父子关系。无明管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式。
有名管道也是一种半双工的通信方式,但是它允许无亲缘关系进程间的通信。

# 共享内存
共享内存就是映射一段能被其他进程所访问的内存,这段共享内存由一个进程创建,但多个进程都可以访问.共享内存是最快的IPC(进程间通信)方式,它是针对其它进程间通信方式运行效率低而专门设计的.它往往与其他通信机制,如信号量,配合使用,来实现进程间的同步与通信.

优点：无须复制，快捷，信息量大；缺点：1）通信是通过将共无法实现享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题；2)利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

# **线程**之间的通信方式

## 锁机制：包括互斥锁、条件变量、读写锁
   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
## 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量
## 信号机制(Signal)：类似进程间的信号处理
    线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。


## 批处理系统中的调度
1. 先来先服务
2. 最短作业优先
3. 最短剩余时间优先
## 交互式系统中的调度
1. 轮转调度
2. 优先级调度
3. 多级队列
4. 最短进程优先
# 虚拟内存
分页

虚拟地址
> 虚拟地址被分成虚拟页号和偏移量两部分。
* 页表项 ：页框号、“在/不在”位、保护位（指出一个页允许什么类型的访问，如读写执行）、修改（modified）位和访问（referenced）位、禁止高速缓存位。

* 虚拟地址空间

* 转换检测缓冲区(Translation Lookaside Buffer, TLB),有时称为相联存储器(associate memory)或快表。

内存管理单元(MMU)

## 针对大内存的页表
1. 多级页表、页目录指针表
2. 倒排页表(inverted page table),实际内存中的每个页框对应一个表项，而不是每个虚拟页面对应一个表项。

页面置换算法
1. 最近未使用页面置换算法(Not Recently Used, 最近未使用)，页面被访问(读或写)时设置R位，被修改设置M位。
2. FIFO(First-In First-Out,先进先出)
3. 最近最少使用(Least Recently Used, LRU),代价高
> 用软件模拟LRU，方案NFU(Not Frequently)
4. 工作集页面置换算法
* 请求调页(demand paging)，页面在需要时被调入，而不是预先装入
* 局部性访问

一个进程当前正在使用的页面的集合称为它的工作集

请求调页与预先调页

## 分页系统中的设计问题
1. 局部分配策略与全局分配策略：缺页中断时，在寻找替换页面时前者只考虑分配给进程A的页面，后也考虑所有在内存中的页面。

2. 分离的指令空间和数据空间：为指令(程序正文)和数据设置分离的地址空间，分别称为I空间和D空间。
3. 共享页面：共享只读的页面。写时复制：从来不会执行写操作的页面是不需要复制的，只有实际修改的数据页面需要复制。
4. 共享库。
5. 内存映射文件：进程可以通过发起一个系统调用，将一个文件映射到其虚拟地址空间的一部分。

## 缺页中断处理
1. 硬件陷入内核，在战队中保存程序计数器
2. 启动一个汇编代码例程保存通用寄存器和其他易失的信息。
3. 操作系统尝试发现需要哪个虚拟页面。
4. 一旦知道了发生缺页中断的虚拟地址，操作系统检查这个地址是否有效，并检查存取与保护是否一致。如果不一致，向进程发出一个信号或杀掉该进程。如果地址有效且灭有保护错误发生，系统则检查是否有空闲页框。如果没有空闲页框，执行页面置换算法寻找一个页面来淘汰。
5. 如果选择的页框“脏”了，安排该页协会磁盘，并发生一次上下文切换，挂起产生缺页中断的进程，让其他进程运行直至磁盘运输结束。
6. 一旦页框“干净”后，操作系统查找所需也页面在磁盘上的地址，通过磁盘操作将其装入。产生缺页中断的进程仍然被挂起。
7. 当磁盘中断发生时，表明该页已经被装入。
8. 恢复发生缺页中断指令之前的状态，程序计数器重新指向这条指令。
9. 调度引发缺页中断的进程，操作系统返回调用它的汇编语言例程。
10. 该例程恢复寄存器和其他状态信息，返回到用户空间继续进行。

## 采用内存中的表进行链表分配
内存分配表 File Allocation Table, FAT
* 文件包括用户数据和元数据(metadata)两部分,其中i节点(index-node) 存储元数据(文件属性和文件块的磁盘地址,即包括文件大小、创建时间、所有者等信息)
* inode号是文件的唯一标识(例如移动并重命名文件其结果不影响文件的inode号及文件的用户数据)

1. 硬链接就是同一个文件使用了多个别名(一个inode号对应多个文件名)
2. 软链接——符号链接(symbolic linking),用户数据块中存放的内容是另一文件的路径名的指向，软链接就是一个普通文件。
符号链接的问题是需要额外的开销，必须读取包含路径的文件，然后要一个部分一个部分地扫描路径，直到找到i节点。
另一个问题是如果允许链接，文件有两个或多个路径，查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件

## 日志文件系统

## Linux文件系统
* 网络文件系统，如nfs、cifs等
* 磁盘文件系统，如ext4、ext3等
* 特殊文件系统，如proc、sysfs、ramfs、tmpfs等
## 虚拟文件系统(Virtural File System, VFS)
VFS抽象了文件系统的四个基本概念：文件、目录项(dentry)、索引节点(inode)及挂载点

VFS对用户进程有一个“上层接口”,POSIX接口

## I/O实现方式
1. 程序控制I/O
2. 中断驱使I/O
3. DMA的I/O

子进程通过调用系统调用exec来执行用户命令
例子：
在shell中输入如下命令:
cp file1 file2用来建立一个名为file2的file1的副本
1. 在shell调用fork函数之后，子进程定位并执行文件名为cp的可执行文件同时把需要复制的文件信息传递给它
```c
main(argc, argv, envp)
//参数argc表示命令行中包括程序名的项的数目，此时argc的值为3
//参数argv表示一个指向数组的指针，数组的第i项是一个指向命令行中第i各字符串的指针，例如argv[0]指向字符串"cp"
//参数envp是一个指向环境的指针
```

# Linux中的内存管理
代码(包含了形成程序可执行代码的机器指令)、数据(包含了所有程序变量、字符数字和其他数据的存储，包含初始化数据和未初始化数据即BSS)和堆栈段
