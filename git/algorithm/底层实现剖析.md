# unordered_map
```c++
template<typename K, typename V>  //每个节点的结构
struct HashNode
{
    pair<K, V> _kv;
    HashNode<K, V>* _next;

    HashNode(pair<K, V> p):_next(NULL), _kv(p){}
};

template<typename K, typename V, class HashFunc = _HashFunc<K>>  //哈希表的结构，第三个参数是仿函数，为了实现可以存储string
{
    protected:
        vector<Node*> _table;
        size_t _size;
};
//1.用一个vector来作为一个指针数组来存储节点的指针，_size来保存当前哈希表中的有效元素个数。
//2.由于是K/V结构，所以选择一个pair的结构来存储K/V。
//3.vector中的每一个元素都指向一个链表，所有节点中需要一个next域的指针来指向下一个节点（采用单链表表结构）。 
const size_t GetIndex(const K& key) const  //除留余数法定位（使用仿函数）
{
    HashFunc hf;
    size_t hash = hf(key);
    return hash % _table.size();
}
void checkCapacity() //扩容
{
    HashTable<K, V, HashFunc> ht(_table.size());
    for (size_t i = 0; i < _table.size(); ++i)
		{
			Node* cur = _table[i];
			while (cur)
			{
				ht.Insert(cur->_kv);
				cur = cur->_next;
			}
		}
 
		_table.swap(ht._table);
}
//因此为了实现string的数据存储，就必须使用仿函数来完成模板中不同类型对象的推演。并且利用模板参数，以及特化来实现。 
//仿函数
template<typename K>
struct _HashFunc
{
    size_t operator()(const K& key)
    {
        return key;
    }
};

template<> //模板的特化
struct _HashFunc<string>
{
    size_t operator()(const string& key)
    {
        return BKDRHash(key.c_str());
    }
    size_t BKDRHash(const char* str) //字符串哈希算法
    {
        register size_t hash = 0;
        while(*str)
        {
            hash = hash * 131 + *str;
            str++;
        }
        return hash;
    }
};
```

# C++符号表
C++符号修饰 （Name Decoration）  /
> 为了解决多模块的符号冲突问题:首先出现的一个问题是C++允许多个不同参数类型的函数拥有一样的名字，就是所谓的函数重载；另外C++还在语言级别支持名称空间，即允许在不同的名称空间有多个同样名字的符号。

> 函数签名（Function Signature），函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数签名用于识别不同的函数

在编译器及链接器处理符号时，它们使用某种名称修饰的方法，使得每个函数签名对应一个修饰后名称（Decorated Name）。
```c++
int func(int);   //_Z4funci (都以_Z开头)
float func(float);   //_Z4funcf
class C {
    int func(int);   //_ZN1C4funcEi （嵌套的名字后面紧跟N， 各个命名空间和类的名字，紧跟着各自的字符串长度，参数列表跟在E后面）
    class C2 {
        int func(int);  //_ZN1C2C24funcEi
    };
};
namespace N {
    int func(int);  //_ZN1N4funcEi
    class C {
        int func(int);  //ZN1N1C4funcEi
    };
}
```

C++中的全局变量和静态变量也有同样的机制。
对于全局变量来说，它跟函数一样都是一个全局可见的名称，它也遵循上面的名称修饰机制，比如一个名称空间foo中的全局变量bar，它修饰后的名字为：_ZN3foo3barE。
值得注意的是，变量的类型并没有被加入到修饰后名称中，所以不论这个变量是整形还是浮点型甚至是一个全局对象，它的名称都是一样的。

名称修饰机制也被用来防止静态变量的名字冲突。比如main()函数里面有一个静态变量叫foo，而func()函数里面也有一个静态变量叫foo。为了区分这两个变量，GCC会将它们的符号名分别修饰成两个不同的名字_ZZ4mainE3foo和_ZZ4funcvE3foo，这样就区分了这两个变量

> const定义在全局变量，通过指针间接修改使会出现运行时runtime memory violation
本质上，为什么2个const一个能改一个不能，就是因为变量所在的存储区不同。

函数级变量是在函数的帧里的，程序拥有对这个存储区写的权限。

而全局性的const变量是放在另一个存储区里的，程序默认不拥有写权限。

函数重载的关键是函数的参数列表，也就是函数签名（Function Signature）

# 函数模板
## 显示具体化(explicit specialization)
```c++
// non-template function prototype
void Swap(job &, job &);

// template prototype
template <class Any>
void Swap(Any &, Any &);

// explicit specialization for the job type
template <> void Swap<job> (job &, job &);

```

> 编译器使用模板为特定类型生成函数定义时，得到的是模板实例(instantiation)。模板并非函数定义，但使用int的模板实例是函数定义，这种实例化方式被称为隐式实例化(implicit instantiation)，因为编译器之所以知道需要进行定义，是由于程序调用Swap()函数时提供了int参数

* **显示实例化(explicit instantiation)**句法：声明所需的种类———用<>符号指示类型，并在声明前加入关键字template
> template void Swap<int> (int, int);
* 编译器将使用Swap()模板生成一个使用int类型的实例，“使用Swap()模板生成int类型的函数定义”

* 区别于**显示具体化(explicit specialization)**：
> template <> void Swap<int> (int &, int &);
* “不要使用Swap()模块来生成函数定义，而应使用独立的、专门的函数定义显示地为int类型生成函数定义”。这些原型必须有自己的函数定义。区别在于template有<>。

## 重载解析（overloading resolution）
1. 创建候选函数列表
> 名称于被调用的函数相同的函数

2. 使用候选函数列表创建可行函数列表
> 筛选：参数能被隐式转换的函数

3. 确定是否有最佳的可行函数
> 完全匹配，但常规函数优先于模板
提升转换（char和shorts自动转换为int，float自动转换为double）
标准转换（int转换为char, long转换为double）
用户定义的转换

### 完全匹配和最佳匹配

# 存储说明符(storage class specifier)
mutable 即是结构变量为const,其某个成员也可以被修改
# cv-限定符（cv-qualifier）
const
volatile(可变的)

### pragma once
 为了避免同一个头文件被包含(include)多次,C/C++中有两种宏实现方式:一种是#ifndef方式;另一种是#pragma once方式。

# <assert.h>头文件
assert.h是c标准库的一个头文件，该头文件的主要目的就是提供一个assert的宏定义。

assert只是对所给的表达式求值，就像if判断语句中一样，然后如果该值为真则正常运行，否则报错，并调用abort(),产生异常中断，exit出来。

该宏可以屏蔽掉，只需在包含assert.h之前＃define NDEBUG，想开再#undef。从这里可以看出预处理带来的方便。

## 有关返回对象的说明
如果函数返回（通过调用的对象的方法或将对象作为参数）传递给它的对象，可以通过传递引用来提高方法的效率。

* 返回对象将调用赋值构造函数，而返回引用不会。
* 引用指向的对象应该在调用函数执行时存在。

## 返回指向非const对象的引用
情形：重载赋值操作符以及重载与cout一起使用的<<操作符（后者必须这样做）。
```c++
//operator=()的返回值用于连续赋值
String s1("Good stuff");
String s2, s3;
s3 = s2 = s1;
//s2.operator=(s1)的返回值被赋给s3。为此，返回String对象或String对象的引用都是可行的，但通过使用引用，可避免该函数调用String的赋值构造函数来创建一个新的String对象。在这个例子中，返回类型不是const，因为方法方法operator=()返回一个指向s2的引用，可以对齐进行修改。

//operator<<()的返回值用于串接输出
String s1("Good stuff");
cout << s1 << "is coming!";
//operator<<(cout, s1)的返回值称为一个用于显示后面字符常的对象，必须是ostream&,如果返回类型ostream,将要求调用ostream类的赋值构造函数，而ostream没有公有的赋值构造函数
```

#C++多态的实现原理与内存模型
## 通过虚函数机制实现在程序运行时根据调用对象来判断具体调用哪一个函数
* 父类类别的指针（或者引用）指向其子类的实例，然后通过父类的指针（或者引用）调用实际子类的成员函数。

* 在每个包含有虚函数的类的对象的最前面(是指这个对象对象内存布局的最前面)都有一个称之为**虚函数指针(vptr)**的东西指向**虚函数表(vtbl)**,这个虚函数表(这里仅讨论最简单的单一继承的情况，若果是多重继承，可能存在多个虚函数表)里面存放了这个类里面所有虚函数的指针，当我们要调用里面的函数时通过查找这个虚函数表来找到对应的虚函数

# RTTI机制
RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

# 一致性Hash性质
* 平衡性（Balance）:哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用
* 单调性（Monotonicity）:哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区
* 分散性（Spread）
好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。
* 负载（Load)
负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

# mysql索引底层实现
* hash表方案
优点：检索的时间复杂度为O(1)
缺点：范围查找效率低

* BST(二叉查找树)方案
时间复杂度是O(lgn)，但极端情况下回退化为线性链表

* 红黑树
当二叉树处于一个不平衡状态时，红黑树就会自动左旋右旋节点以及节点变色，调整树的形态，使其保持基本的平衡状态（时间复杂度为 O（logn）），也就保证了查找效率不会明显减低。
数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗

* 自平衡二叉树 AVL 树
从查找效率而言，AVL 树查找的速度要高于红黑树的查找效率（AVL 树是 4 次比较，红黑树是 6 次比较）。从树的形态看来，AVL 树不存在红黑树的“右倾”问题。也就是说，大量的顺序插入不会导致查询性能的降低，这从根本上解决了红黑树的问题。

> 数据库查询数据的瓶颈在于磁盘 IO，如果使用的是 AVL 树，我们每一个树节点只存储了一个数据，我们一次磁盘 IO 只能取出来一个节点上的数据加载到内存里，那比如查询 id=7 这个数据我们就要进行磁盘 IO 三次，这是多么消耗时间的。所以我们设计数据库索引时需要首先考虑怎么尽可能减少磁盘 IO 的次数。

> 磁盘 IO 有个有个特点，就是从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样的，我们就可以根据这个思路，我们可以在一个树节点上尽可能多地存储数据，一次磁盘 IO 就多加载点数据到内存，这就是 B 树，B+树的的设计原理了。

* B树
优秀检索速度，时间复杂度：B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数；
尽可能少的磁盘 IO，加快了检索速度；
可以支持范围查找。

* B+树
第一，B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。

第二，B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。

## MyISAM查找性能佳，不支持事务处理
创建表后生成的文件：frm：创建表的语句
MYD:表里面的数据文件
MYI:表里面的索引文件
数据和索引分开：非聚集索引方式
> MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。

## Innodb支持ACID兼容的事务功能，并支持行级锁
创建表后生成的文件：frm：创建表的语句；idb：表里面的数据+索引文件
数据和索引分开：聚集索引方式
> 数据和索引都存储在同一个文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树，如左下图所示，而 B+树的叶子节点存储的是主键 ID 对应的数据

我们要给 user_name 这个字段加索引，那么 InnoDB 就会建立 user_name 索引 B+树，节点里存的是 user_name 这个 KEY，叶子节点存储的数据的是**主键 KEY**。辅助索引搜索需要检索两遍索引:首先检索辅助索引获得主键,然后用主键到主索引中检索获得记录(**回表**)。

> 尽量在 InnoDB 上采用**自增字段**做表的主键。因为 InnoDB 数据文件本身是一棵B+Tree,非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整,十分低效。如果表使用自增主键,那么每次插入新的记录,记录就会顺序添加到当前索引节点的后续位置,当一页写满,就会自动开辟一个新的页。

### 建立索引的原则：
* 较频繁的作为查询条件的字段应该创建索引；
* 唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；
* 更新非常频繁的字段不适合创建索引。

### Multi-Range Read Optimization(MRR优化)
解决背景：当基于普通索引查询时，顺序是按照普通索引的顺序来的，那就很有可能再回表的过程中不是按照主键顺序去读取数据，造成随机读现象，拖累性能。

查找的数量越多，越能体现MRR的顺序IO的优势

> MRR 会根据索引将 row ID 即主键值缓存起来，然后将他们按照主键值进行排序，最后依次拿出主键值执行回表操作

### Batched Key Access Join(BKA)

## 笛卡尔积 
> select 字段 from 表1，表2[,表N]; 
笛卡尔积简单点理解：有两个集合A和B，笛卡尔积表示A集合中的元素和B集合中的元素任意相互关联产生的所有可能的结果。

假如A中有m个元素，B中有n个元素，A、B笛卡尔积产生的结果有m*n个结果，相当于循环遍历两个集合中的元素，任意组合。

## 内连接
> select 字段 from 表1 inner join 表2 on 链接条件
内连接相当于在笛卡尔积的基础上加上了连接的条件。

## 外连接
外连接涉及到2个表，分为：主表和从表，要查询的信息主要来自于哪个表，谁就是主表。

外连接查询结果为主表中所有记录。如果从表中有和它匹配的，则显示匹配的值，这部分相当于内连接查询出来的结果；如果从表中没有和它匹配的，则显示null。

最终：外连接查询结果 = 内连接的结果 + 主表中有的而内连接结果中没有的记录。

外连接分为2种：

左外链接：使用left join关键字，left join左边的是主表。

右外连接：使用right join关键字，right join右边的是主表。

# 场景：秒杀如何防止超卖
多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是**线程安全**的）
如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用MySQL的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。

> 假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景），多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。

1. 悲观锁思路
悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。

分析：场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的**平均响应时间**，结果是**可用连接数被耗尽**，系统陷入异常。

2. FIFO队列思路
直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。

分析：高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。

3. 乐观锁思路
乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的**版本号**，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。如：Redis中的watch。

# Redis集群扩容和缩容
增加节点的顺序是先增加Master主节点，然后在增加Slave从节点。

删除的顺序是先删除Slave从节点，然后在删除Master主节点。

## string互相转换int
```c++
//string转int
string num = "123";
int n = atoi(num.c_str());
//int转string
string s = to_string(n);
```